<template><h1 id="协程-coroutines" tabindex="-1"><a class="header-anchor" href="#协程-coroutines" aria-hidden="true">#</a> 协程 Coroutines</h1>
<nav class="table-of-contents"><ul><li><RouterLink to="#介绍">介绍</RouterLink></li><li><RouterLink to="#跨帧逻辑">跨帧逻辑</RouterLink></li><li><RouterLink to="#工作原理">工作原理</RouterLink></li><li><RouterLink to="#协程和异步">协程和异步</RouterLink></li><li><RouterLink to="#高级用法">高级用法</RouterLink></li></ul></nav>
<h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍" aria-hidden="true">#</a> 介绍</h2>
<p>Babylon 5.0带来了一种新的编写逻辑的方式，它可以随着时间的推移而运行，即协程coroutines!</p>
<p>有使用<a href="https://docs.unity3d.com/cn/current/Manual/Coroutines.html" target="_blank" rel="noopener noreferrer">Unity3D<ExternalLinkIcon/></a>和某些<a href="https://en.cppreference.com/w/cpp/language/coroutines" target="_blank" rel="noopener noreferrer">本地API<ExternalLinkIcon/></a>经验的开发者可能已经熟悉了coroutines的概念和用法。广义上讲，coroutine只是一个可以暂停和恢复的函数。在Babylon.js中，我们通过Observable类提供了coroutine支持，允许逻辑 &quot;分散 &quot;在多个时刻——最常见的是跨越多个帧。</p>
<h2 id="跨帧逻辑" tabindex="-1"><a class="header-anchor" href="#跨帧逻辑" aria-hidden="true">#</a> 跨帧逻辑</h2>
<p>假设你有一连串的动作，这些动作在逻辑上是连续的，但你不希望它们都发生在同一帧。例如，假设你想生成三个网格，但你不想在同一帧上生成它们，这样就有可能造成帧的滞后。那么，从逻辑上讲，你想做的是如下事情：</p>
<ul>
<li>生成第一个网格。</li>
<li>等到下一帧。</li>
<li>生成第二个网格。</li>
<li>等待到下一帧。</li>
<li>生成第三个网格。</li>
</ul>
<p>如果没有coroutines，你可以通过工作队列、链式的Promise/回调等方式来完成这个任务，这其中有很多不同的技巧。然而，有了coroutines，你几乎可以通过直接写出上面的逻辑来完成这个任务。</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">spawnMeshesCoroutine</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">spawnTheFirstMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span><span class="token punctuation">;</span>
    <span class="token function">spawnTheSecondMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span><span class="token punctuation">;</span>
    <span class="token function">spawnTheThirdMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
scene<span class="token punctuation">.</span>onBeforeRenderObservable<span class="token punctuation">.</span><span class="token function">runCoroutineAsync</span><span class="token punctuation">(</span><span class="token function">spawnMeshesCoroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个coroutine将使生成三个网格的逻辑分布在三个帧上。例如，如果你在第100帧上运行上述代码，那么 spawnTheFirstMesh 将在第100帧上被调用，spawnTheSecondMesh 将在第101帧上被调用，而 spawnTheThirdMesh 将在第102帧上被调用。就这样，你已经有了在多个帧上运行的逻辑了！</p>
<h2 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理" aria-hidden="true">#</a> 工作原理</h2>
<p>Babylon.js coroutines结合了<a href="https://zh.javascript.info/generators" target="_blank" rel="noopener noreferrer">JavaScript生成器<ExternalLinkIcon/></a>，使其尽可能容易地将逻辑分散到多个帧上。生成器函数（语法为function* 的ES6功能）并不像传统函数那样返回一个简单的返回值对象。相反，它们返回一个中间对象，允许函数内部的代码以 &quot;块&quot;的形式运行，不同的块用关键字 yield 分开。然后，这个中间对象可以被反复调用，每次调用时，生成器函数将从它最后 &quot;暂停 &quot;的地方 &quot;恢复&quot;，并继续运行，直到它到达下一个yield或者到达函数的终点。</p>
<p>这个中间的、可重复调用的对象（生成器函数）就是 <code v-pre>Observable.runCoroutineAsync</code> 作为参数的东西。coroutine 程序所运行的 observable 会调用该生成器函数——导致 coroutine 程序的另一 &quot;块&quot;代码的运行——当每次该 Observable 被通知的时候。这使得编写由 Observable 监控的特定事件发生时每次&quot;进展&quot;的逻辑变得非常容易。</p>
<h2 id="协程和异步" tabindex="-1"><a class="header-anchor" href="#协程和异步" aria-hidden="true">#</a> 协程和异步</h2>
<p>Coroutines是一种简单明了的方式，可以将逻辑分散到不同的时间，但它们并不是真正的异步，如Promise。Coroutines是按帧轮询的（或者更准确地说，是按Observable通知轮询的），所以它们对于密集发生的逻辑非常有效——例如，在一系列后续帧中发生的逻辑序列。相比之下，Promise对于那些发生得比较稀疏的逻辑非常有效——网络请求、文件I/O、WebWorker调用，等等。因此，Coroutines和真正的异步有独立但互补的优势，所以Babylon.js使得在真正的异步方法中使用一个Coroutine很容易，反之亦然。</p>
<p><code v-pre>Observable.runCoroutineAsync</code>，顾名思义，返回一个<code v-pre>Promise&lt;void&gt;</code>，这个Promise会在coroutine完成时被解析，或者在coroutine被取消时被拒绝。这使得 coroutines 可以像真正的异步函数一样被等待。例如，下面的代码将打印 &quot;Start&quot;，等待一秒钟，在相邻的帧上打印 &quot;A &quot;和 &quot;B&quot;，然后在打印 &quot;End &quot;之前再等待一秒钟。</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">coroutineFunc</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">asynchronousFunction</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> <span class="token constant">BABYLON</span><span class="token punctuation">.</span>Tools<span class="token punctuation">.</span><span class="token function">DelayAsync</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> scene<span class="token punctuation">.</span>onBeforeRenderObservable<span class="token punctuation">.</span><span class="token function">runCoroutineAsync</span><span class="token punctuation">(</span><span class="token function">coroutineFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> <span class="token constant">BABYLON</span><span class="token punctuation">.</span>Tools<span class="token punctuation">.</span><span class="token function">DelayAsync</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"End"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">asynchronousFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://playground.babylonjs.com/#0XL0ZS#1" target="_blank" rel="noopener noreferrer">协程和异步示例<ExternalLinkIcon/></a></p>
<p>同样地，暂停一个 coroutine 直到一个真正的异步函数完成也很容易。这是用yield关键字实现的。具体细节超出了本文的范围，但可以把yield看作是一个中间的 return 命令，它暂停了一个生成器函数，而不是终止它。在Babylon.js coroutines中，我们通常使用yield自身来 &quot;return&quot;任何东西，coroutine系统会将其解释为现在暂停coroutine的命令，并在下次通知Observable时恢复它。然而，我们也可以用一个Promise。</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">yield</span> <span class="token constant">BABYLON</span><span class="token punctuation">.</span>Tools<span class="token punctuation">.</span><span class="token function">DelayAsync</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当我们 yield 一个Promise时，coroutine系统将再次立即暂停coroutine；然而，直到 yield 的Promise被解析后第一次通知Observable时，它才会再次恢复。因此，在 coroutine 中 yield 一个 Promise 非常像在一个真正的异步函数中等待一个 Promise：它暂停了相关函数的执行，直到 Promise 被解析。</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">asynchronousFunc</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token constant">BABYLON</span><span class="token punctuation">.</span>Tools<span class="token punctuation">.</span><span class="token function">DelayAsync</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">coroutineFunc</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token function">asynchronousFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

scene<span class="token punctuation">.</span>onBeforeRenderObservable<span class="token punctuation">.</span><span class="token function">runCoroutineAsync</span><span class="token punctuation">(</span><span class="token function">coroutineFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码显示了一个产生Promise的coroutine；它将在相邻的帧中打印 &quot;A &quot;和 &quot;B&quot;，然后等待一秒钟，然后在相邻的帧中打印 &quot;C &quot;和 &quot;D&quot;。</p>
<p><a href="https://playground.babylonjs.com/#0XL0ZS#3" target="_blank" rel="noopener noreferrer">yield Promise示例<ExternalLinkIcon/></a></p>
<h2 id="高级用法" tabindex="-1"><a class="header-anchor" href="#高级用法" aria-hidden="true">#</a> 高级用法</h2>
<p>上面的例子都说明了简单的、线性的、有限的逻辑序列，但coroutine并不局限于此。Coroutines可以是无限的，分支的，以及任意复杂的。事实上，完全可以用coroutine来编写完整的核心逻辑循环。</p>
<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">playGame</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">displayGameLogo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">enterKeyPressed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">escapeKeyPressed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">yield</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">escapeKeyPressed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">yield</span> <span class="token function">loadTheSceneAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">spawnTheFirstMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span><span class="token punctuation">;</span>
    <span class="token function">spawnTheSecondMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span><span class="token punctuation">;</span>
    <span class="token function">spawnTheThirdMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">escapeKeyPressed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">jumpButtonPressed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 30 frame uninterruptable parametric jump animation</span>
            <span class="token keyword">const</span> <span class="token function-variable function">jump</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;=</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span><span class="token punctuation">;</span> t <span class="token operator">+=</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span> <span class="token operator">/</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    playerCharacter<span class="token punctuation">.</span>y <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// Suspend game logic until jump animation is complete</span>
            <span class="token comment">// (Nonsensical thing to do, just for demonstration purposes)</span>
            <span class="token keyword">yield</span> scene<span class="token punctuation">.</span>onBeforeRenderObservable<span class="token punctuation">.</span><span class="token function">runCoroutineAsync</span><span class="token punctuation">(</span><span class="token function">jump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">yield</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">yield</span> <span class="token function">saveGameStateAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">showGoodbyeMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
scene<span class="token punctuation">.</span>onBeforeRenderObservable<span class="token punctuation">.</span><span class="token function">runCoroutineAsync</span><span class="token punctuation">(</span><span class="token function">playGame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></template>
