import { DropdownHelper } from '../util/util'

const MenuGenerator = {};

MenuGenerator.materialType = new DropdownHelper([
  ['StandardMaterial', 'StandardMaterial'],
  ['PBRMaterial', 'PBRMaterial'],
  ['BackgroundMaterial', 'BackgroundMaterial'],
])

const alpha = ['alpha', 'alpha', 'NUM', '1', 'Sets or gets the alpha value of the material'],
  alphaMode = ['alphaMode', 'alphaMode', 'NUM', '', '0	ALPHA_DISABLE	\n 1	ALPHA_ADD	\n 2	ALPHA_COMBINE	\n 3	ALPHA_SUBTRACT	\n 4	ALPHA_MULTIPLY	\n 5	ALPHA_MAXIMIZED	\n 6	ALPHA_ONEONE	\n 7	ALPHA_PREMULTIPLIED	\n 8	ALPHA_PREMULTIPLIED_PORTERDUFF	\n 9	ALPHA_INTERPOLATE	\n 10	ALPHA_SCREENMODE'],
  ambientColor = ['ambientColor', 'ambientColor', 'COLOR3', [0, 0, 0], 'The color of the material lit by the environmental background lighting.'],
  ambientTexture = ['occlusionTexture', 'ambientTexture', 'NONE', '', 'AKA Ambient Texture in other nomenclature, it helps adding baked shadows into your material.'],
  transparencyMode = ['transparencyMode', 'transparencyMode', 'NUM', '0', '0	OPAQUE	\n1	ALPHATEST	\n2	ALPHABLEND	\n3	ALPHATESTANDBLEND'],
  backFaceCulling = ['backFaceCulling', 'backFaceCulling', 'BOOL', 'FALSE', 'Sets or gets the culling state (true to enable culling, false to disable)'],
  bumpTexture = ['bumpTexture', 'bumpTexture', 'NONE', '', 'Bump mapping is a technique to simulate bump and dents on a rendered surface.'],
  disableLighting = ['disableLighting', 'disableLighting', 'BOOL', 'FALSE', 'Does lights from the scene impacts this material. It can be a nice trick for performance to disable lighting on a fully emissive material.'],
  maxSimultaneousLights = ['maxSimultaneousLights', 'maxSimultaneousLights', 'NUM', '6', 'Defines the maximum number of lights that can be used in the material'],
  sideOrientation = ['sideOrientation', 'sideOrientation', 'NUM', '0', 'Stores the value for side orientation'],
  twoSidedLighting = ['twoSidedLighting', 'twoSidedLighting', 'BOOL', 'FALSE', 'If sets to true and backfaceCulling is false, normals will be flipped on the backside.'],

  wireframe = ['wireframe', 'wireframe', 'BOOL', 'FALSE', 'Sets or gets the state of wireframe mode'],
  zOffset = ['zOffset', 'zOffset', 'NUM', '', 'Stores the z offset Factor value'];

MenuGenerator.StandardMaterial = new DropdownHelper([
  alpha,
  alphaMode,
  ambientColor,
  ambientTexture,
  backFaceCulling,
  bumpTexture,
  ['diffuseColor', 'diffuseColor', 'COLOR3', [0, 0, 0], 'The basic color of the material as viewed under a light.'],
  ['diffuseTexture', 'diffuseTexture', 'NONE', '', 'The basic texture of the material as viewed under a light.'],
  disableLighting,
  ['emissiveColor', 'emissiveColor', 'COLOR3', [0, 0, 0], 'Define the color of the material as if self lit. This will be mixed in the final result even in the absence of light.'],
  ['emissiveTexture', 'emissiveTexture', 'NONE', '', 'Define texture of the material as if self lit. This will be mixed in the final result even in the absence of light.'],
  ['indexOfRefraction', 'indexOfRefraction', 'NUM', '1', 'In case of refraction, define the value of the index of refraction.'],
  ['invertNormalMapX', 'invertNormalMapX', 'BOOL', 'FALSE', 'If sets to true, x component of normal map value will invert (x = 1.0 - x).'],
  ['invertNormalMapY', 'invertNormalMapY', 'BOOL', 'FALSE', 'If sets to true, y component of normal map value will invert (y = 1.0 - y).'],
  ['invertRefractionY', 'invertRefractionY', 'BOOL', 'FALSE', 'Invert the refraction texture alongside the y axis. It can be useful with procedural textures or probe for instance.'],
  ['lightmapTexture', 'lightmapTexture', 'NONE', '', 'Complex lighting can be computationally expensive to compute at runtime. To save on computation, lightmaps may be used to store calculated lighting in a texture which will be applied to a given mesh.'],
  ['linkEmissiveWithDiffuse', 'linkEmissiveWithDiffuse', 'BOOL', 'FALSE', 'If true, some kind of energy conservation will prevent the end result to be more than 1 by reducing the emissive level when the final color is close to one.'],
  maxSimultaneousLights,
  ['opacityTexture', 'opacityTexture', 'NONE', '', 'Define the transparency of the material from a texture. The final alpha value can be read either from the red channel (if texture.getAlphaFromRGB is false) or from the luminance or the current texel (if texture.getAlphaFromRGB is true)'],
  ['parallaxScaleBias', 'parallaxScaleBias', 'NUM', '0.05', 'Apply a scaling factor that determine which "depth" the height map should reprensent. A value between 0.05 and 0.1 is reasonnable in Parallax, you can reach 0.2 using Parallax Occlusion.'],
  ['pointSize', 'pointSize', 'NUM', '1', 'Stores the size of points'],
  ['reflectionTexture', 'reflectionTexture', 'NONE', '', 'Define the texture used to display the reflection.'],
  ['refractionTexture', 'refractionTexture', 'NONE', '', 'Define the texture used to display the refraction.'],
  ['roughness', 'roughness', 'NUM', '0', 'Specifies the roughness scalar of the metallic/roughness workflow. Can also be used to scale the roughness values of the metallic texture.'],
  sideOrientation,
  ['specularColor', 'specularColor', 'COLOR3', [0, 0, 0], 'Define how the color and intensity of the highlight given by the light in the material.'],
  ['specularPower', 'specularPower', 'NUM', '1', 'Defines how sharp are the highlights in the material. The bigger the value the sharper giving a more glossy feeling to the result. Reversely, the smaller the value the blurrier giving a more rough feeling to the result.'],
  ['specularTexture', 'specularTexture', 'NONE', '', 'Define how the color and intensity of the highlight given by the light in the material.'],
  transparencyMode,
  twoSidedLighting,
  ['useAlphaFromDiffuseTexture', 'useAlphaFromDiffuseTexture', 'BOOL', 'FALSE', 'Does the transparency come from the diffuse texture alpha channel.'],
  ['useEmissiveAsIllumination', 'useEmissiveAsIllumination', 'BOOL', 'FALSE', 'If true, the emissive value is added into the end result, otherwise it is multiplied in.'],
  ['useGlossinessFromSpecularMapAlpha', 'useGlossinessFromSpecularMapAlpha', 'BOOL', 'FALSE', 'Defines if the glossiness/roughness of the material should be read from the specular map alpha channel'],
  ['useLightmapAsShadowmap', 'useLightmapAsShadowmap', 'BOOL', 'FALSE', 'In case of light mapping, define whether the map contains light or shadow informations.'],
  ['useObjectSpaceNormalMap', 'useObjectSpaceNormalMap', 'BOOL', 'FALSE', 'Allows using an object space normal map (instead of tangent space).'],
  ['useParallax', 'useParallax', 'BOOL', 'FALSE', 'Is parallax enabled or not.'],
  ['useParallaxOcclusion', 'useParallaxOcclusion', 'BOOL', 'FALSE', 'Is parallax occlusion enabled or not. If true, the outcome is way more realistic than traditional Parallax but you can expect a performance hit that worthes consideration.'],
  ['useReflectionFresnelFromSpecular', 'useReflectionFresnelFromSpecular', 'BOOL', 'FALSE', 'If true automatically deducts the fresnels values from the material specularity.'],
  ['useReflectionOverAlpha', 'useReflectionOverAlpha', 'BOOL', 'FALSE', 'Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones). A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.'],
  ['useSpecularOverAlpha', 'useSpecularOverAlpha', 'BOOL', 'FALSE', 'Specifies that the material will keep the specular highlights over a transparent surface (only the most luminous ones). A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.'],
  wireframe,
  zOffset,
])

MenuGenerator.PBRMaterial = new DropdownHelper([
  ['diffuseColor', 'albedoColor', 'COLOR3', [255, 255, 255], 'AKA Albedo Color in other nomenclature.'],
  ['diffuseTexture', 'albedoTexture', null, '', 'AKA Albedo Texture in other nomenclature.'],
  alpha,
  alphaMode,
  ['alphaCutOff', 'alphaCutOff', 'NUM', '', 'Defines the alpha limits in alpha test mode.'],
  ambientColor,
  ambientTexture,
  ['occlusionTextureIntensity', 'ambientTextureStrength', 'NUM', '', 'AKA Ambient Texture Strength in other nomenclature.'],
  backFaceCulling,
  ['bumpTexture', 'bumpTexture', null, '', 'Stores surface normal data used to displace a mesh in a texture.'],
  ['emissiveColor', 'emissiveColor', 'COLOR3', [0, 0, 0], ''],
  ['emissiveIntensity', 'emissiveIntensity', 'NUM', '', 'Intensity of the emissive part of the material. This helps controlling the emissive effect without modifying the emissive color.'],
  ['emissiveTexture', 'emissiveTexture', null, '', 'Stores the emissive values in a texture.'],
  ['enableSpecularAntiAliasing', 'enableSpecularAntiAliasing', 'BOOL', 'FALSE', 'Enables specular anti aliasing in the PBR shader. It will both interacts on the Geometry for analytical and IBL lighting. It also prefilter the roughness map based on the bump values.'],
  ['environmentBRDFTexture', 'environmentBRDFTexture', null, '', 'Let user defines the brdf lookup texture used for IBL.'],
  ['environmentIntensity', 'environmentIntensity', 'NUM', '1', 'Intensity of the environment e.g. how much the environment will light the object either through harmonics for rough material or through the reflection for shiny ones.'],
  ['glossiness', 'microSurface', 'NUM', '', 'AKA microSurface in other nomenclature.'],
  ['glossinessTexture', 'microSurfaceTexture', null, '', 'Used to enable roughness/glossiness fetch from a separate channel depending on the current mode. Gray Scale represents roughness in metallic mode and glossiness in specular mode.'],
  ['invertNormalMapX', 'invertNormalMapX', 'BOOL', 'FALSE', 'If sets to true, x component of normal map value will invert (x = 1.0 - x).'],
  ['invertNormalMapY', 'invertNormalMapY', 'BOOL', 'FALSE', 'If sets to true, y component of normal map value will invert (y = 1.0 - y).'],
  ['lightmapTexture', 'lightmapTexture', null, '', 'Stores the pre-calculated light information of a mesh in a texture.'],
  maxSimultaneousLights,
  ['metallic', 'metallic', 'NUM', '0', 'Specifies the metallic scalar of the metallic/roughness workflow. Can also be used to scale the metalness values of the metallic texture.'],
  ['metallicF0Factor', 'metallicF0Factor', 'NUM', '', 'In metallic workflow, specifies an F0 factor to help configuring the material F0. \n By default the indexOfrefraction is used to compute F0; \nThis is used as a factor against the default reflectance at normal incidence to tweak it. \n F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor; \n F90 = metallicReflectanceColor;'],
  ['metallicReflectanceColor', 'metallicReflectanceColor', 'COLOR3', [0, 0, 0], 'In metallic workflow, specifies an F90 color to help configuring the material F90.\n By default the F90 is always 1;\n Please note that this factor is also used as a factor against the default reflectance at normal incidence.\n F0 = defaultF0 * metallicF0Factor * metallicReflectanceColor\n F90 = metallicReflectanceColor;'],
  ['metallicReflectanceTexture', 'metallicReflectanceTexture', null, '', 'Defines to store metallicReflectanceColor in RGB and metallicF0Factor in A This is multiplied against the scalar values defined in the material. If useOnlyMetallicFromMetallicReflectanceTexture is true, don\'t use the RGB channels, only A'],
  ['metallicTexture', 'metallicTexture', null, '', 'Used to switch from specular/glossiness to metallic/roughness workflow.'],
  ['opacityTexture', 'opacityTexture', null, '', 'Stores the alpha values in a texture. Use luminance if texture.getAlphaFromRGB is true.'],
  ['parallaxScaleBias', 'parallaxScaleBias', 'NUM', '', 'Controls the scale bias of the parallax mode.'],
  ['reflectanceTexture', 'reflectanceTexture', null, '', 'Defines to store reflectanceColor in RGB This is multiplied against the scalar values defined in the material. If both reflectanceTexture and metallicReflectanceTexture textures are provided and useOnlyMetallicFromMetallicReflectanceTexture is false, metallicReflectanceTexture takes priority and reflectanceTexture is not used'],
  ['reflectionColor', 'reflectionColor', 'COLOR3', [0, 0, 0], 'The color reflected from the material.'],
  ['reflectionTexture', 'reflectionTexture', null, '', 'Stores the reflection values in a texture.'],
  ['reflectivityColor', 'reflectivityColor', 'COLOR3', [0, 0, 0], 'AKA Specular Color in other nomenclature.'],
  ['reflectivityTexture', 'reflectivityTexture', null, '', 'AKA Specular texture in other nomenclature.'],
  ['roughness', 'roughness', 'NUM', '', 'Specifies the roughness scalar of the metallic/roughness workflow. Can also be used to scale the roughness values of the metallic texture.'],
  sideOrientation,
  ['specularIntensity', 'specularIntensity', 'NUM', '', 'This is a special control allowing the reduction of the specular highlights coming from the four lights of the scene. Those highlights may not be needed in full environment lighting.'],
  twoSidedLighting,
  transparencyMode,
  ['unlit', 'unlit', 'BOOL', 'FALSE', 'If set to true, no lighting calculations will be applied.'],
  ['useAlphaFresnel', 'useAlphaFresnel', 'BOOL', 'FALSE', 'A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested. And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)'],
  ['useAlphaFromAlbedoTexture', 'useAlphaFromAlbedoTexture', 'BOOL', 'FALSE', 'Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.'],
  ['useAmbientInGrayScale', 'useAmbientInGrayScale', 'BOOL', 'FALSE', 'Specifies if the ambient texture contains the ambient occlusion information in its red channel only.'],
  ['useAmbientOcclusionFromMetallicTextureRed', 'useAmbientOcclusionFromMetallicTextureRed', 'BOOL', 'FALSE', 'Specifies if the metallic texture contains the ambient occlusion information in its red channel.'],
  ['useAutoMicroSurfaceFromReflectivityMap', 'useAutoMicroSurfaceFromReflectivityMap', 'BOOL', 'FALSE', 'In case the reflectivity map does not contain the microsurface information in its alpha channel,The material will try to infer what glossiness each pixel should be.'],
  ['useHorizonOcclusion', 'useHorizonOcclusion', 'BOOL', 'FALSE', 'This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal makes the reflect vector face the model (under horizon).'],
  ['useLightmapAsShadowmap', 'useLightmapAsShadowmap', 'BOOL', 'FALSE', 'If true, the light map contains occlusion information instead of lighting info.'],
  ['useLinearAlphaFresnel', 'useLinearAlphaFresnel', 'BOOL', 'FALSE', 'A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested. And/Or occlude the blended part. (alpha stays linear to compute the fresnel)'],
  ['useMetallnessFromMetallicTextureBlue', 'useMetallnessFromMetallicTextureBlue', 'BOOL', 'FALSE', 'Specifies if the metallic texture contains the metallness information in its blue channel.'],
  ['useMicroSurfaceFromReflectivityMapAlpha', 'useMicroSurfaceFromReflectivityMapAlpha', 'BOOL', 'FALSE', 'Specifies if the reflectivity texture contains the glossiness information in its alpha channel.'],
  ['useObjectSpaceNormalMap', 'useObjectSpaceNormalMap', 'BOOL', 'FALSE', 'Allows using an object space normal map (instead of tangent space).'],
  ['useOnlyMetallicFromMetallicReflectanceTexture', 'useOnlyMetallicFromMetallicReflectanceTexture', 'BOOL', 'FALSE', 'Specifies that only the A channel from metallicReflectanceTexture should be used. If false, both RGB and A channels will be used'],
  ['useParallax', 'useParallax', 'BOOL', 'FALSE', 'Allows using the bump map in parallax mode.'],
  ['useParallaxOcclusion', 'useParallaxOcclusion', 'BOOL', 'FALSE', 'Allows using the bump map in parallax occlusion mode.'],
  ['useRadianceOcclusion', 'useRadianceOcclusion', 'BOOL', 'FALSE', 'This parameters will enable/disable radiance occlusion by preventing the radiance to lit too much the area relying on ambient texture to define their ambient occlusion.'],
  ['useRadianceOverAlpha', 'useRadianceOverAlpha', 'BOOL', 'FALSE', 'Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones). A car glass is a good example of that. When the street lights reflects on it you can not see what is behind.'],
  ['useRoughnessFromMetallicTextureAlpha', 'useRoughnessFromMetallicTextureAlpha', 'BOOL', 'FALSE', 'Specifies if the metallic texture contains the roughness information in its alpha channel.'],
  ['useRoughnessFromMetallicTextureGreen', 'useRoughnessFromMetallicTextureGreen', 'BOOL', 'FALSE', 'Specifies if the metallic texture contains the roughness information in its green channel.'],
  ['useSpecularOverAlpha', 'useSpecularOverAlpha', 'BOOL', 'FALSE', 'Specifies that the material will keep the specular highlights over a transparent surface (only the most luminous ones). A car glass is a good example of that. When sun reflects on it you can not see what is behind.'],
  wireframe,
  zOffset,
])

MenuGenerator.BackgroundMaterial = new DropdownHelper([
  ['allowShaderHotSwapping', 'allowShaderHotSwapping', null, '', ''],
  ['customShaderNameResolve', 'customShaderNameResolve', null, '', ''],
  ['diffuseTexture', 'diffuseTexture', null, '', ''],
  ['enableNoise', 'enableNoise', null, '', ''],
  maxSimultaneousLights,
  ['opacityFresnel', 'opacityFresnel', null, '', ''],
  ['primaryColor', 'primaryColor', 'COLOR3', [255, 255, 255], ''],
  ['reflectionAmount', 'reflectionAmount', null, '', ''],
  ['reflectionBlur', 'reflectionBlur', null, '', ''],
  ['reflectionFalloffDistance', 'reflectionFalloffDistance', null, '', ''],
  ['reflectionFresnel', 'reflectionFresnel', null, '', ''],
  ['reflectionReflectance0', 'reflectionReflectance0', null, '', ''],
  ['reflectionReflectance90', 'reflectionReflectance90', null, '', ''],
  ['reflectionTexture', 'reflectionTexture', null, '', ''],
  ['sceneCenter', 'sceneCenter', null, '', ''],
  ['shadowLevel', 'shadowLevel', null, '', ''],
  ['shadowLights', 'shadowLights', null, '', ''],
  ['shadowOnly', 'shadowOnly', null, '', ''],
  sideOrientation,
  ['switchToBGR', 'switchToBGR', null, '', ''],
  ['useEquirectangularFOV', 'useEquirectangularFOV', null, '', ''],
  ['useRGBColor', 'useRGBColor', null, '', ''],
  zOffset,
])

MenuGenerator.textureType = new DropdownHelper([
  ['Texture', 'Texture'],
  ['CubeTexture', 'CubeTexture'],
])
const anisotropicFilteringLevel = ['anisotropicFilteringLevel', 'anisotropicFilteringLevel', 'NUM', '4', 'With compliant hardware and browser (supporting anisotropic filtering)\nthis defines the level of anisotropic filtering in the texture.\nThe higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.'],
  coordinatesMode = ['coordinatesMode', 'coordinatesMode', 'NUM', '0', 'How a texture is mapped. \n0-EXPLICIT_MODE\n1-SPHERICAL_MODE\n2-PLANAR_MODE\n3-CUBIC_MODE\n4-PROJECTION_MODE\n5-SKYBOX_MODE\n6-INVCUBIC_MODE\n7-EQUIRECTANGULAR_MODE\n8-FIXED_EQUIRECTANGULAR_MODE\n9-FIXED_EQUIRECTANGULAR_MIRRORED_MODE'],
  hasAlpha = ['hasAlpha', 'hasAlpha', 'BOOL', 'FALSE', 'Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).'],
  invertY = ['invertY', 'invertY', 'BOOL', 'FALSE', 'Gets a boolean indicating if the texture needs to be inverted on the y axis during loading'],
  invertZ = ['invertZ', 'invertZ', 'BOOL', 'FALSE', 'Is Z inverted in the texture (useful in a cube texture).'],
  level = ['level', 'level', 'NUM', '1', 'Intensity or strength of the texture.It is commonly used by materials to fine tune the intensity of the texture'],
  uAng = ['uAng', 'uAng', 'NUM', '0', 'Define an offset on the texture to rotate around the u coordinates of the UVs\nThe angle is defined in radians.'],
  uOffset = ['uOffset', 'uOffset', 'NUM', '0', 'Define an offset on the texture to offset the u coordinates of the UVs'],
  uRotationCenter = ['uRotationCenter', 'uRotationCenter', 'NUM', '0', 'Defines the center of rotation (U)'],
  uScale = ['uScale', 'uScale', 'NUM', '1', 'Define an offset on the texture to scale the u coordinates of the UVs'],
  rotationY = ['rotationY', 'rotationY', 'NUM', '', 'Sets or gets texture matrix rotation angle around Y axis in radians. '],
  url = ['url', 'url', 'TEXT', '', 'Define the url of the texture.'],
  vAng = ['vAng', 'vAng', 'NUM', '0', 'Define an offset on the texture to rotate around the v coordinates of the UVs\nThe angle is defined in radians.'],
  vOffset = ['vOffset', 'vOffset', 'NUM', '0', 'Define an offset on the texture to offset the v coordinates of the UVs'],
  vRotationCenter = ['vRotationCenter', 'vRotationCenter', 'NUM', '0', 'Defines the center of rotation (V)'],
  vScale = ['vScale', 'vScale', 'NUM', '1', 'Define an offset on the texture to scale the v coordinates of the UVs'],
  wAng = ['wAng', 'wAng', 'NUM', '0', 'Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)\nThe angle is defined in radians.'],
  wRotationCenter = ['wRotationCenter', 'wRotationCenter', 'NUM', '0', 'Defines the center of rotation (W)'],
  wrapR = ['wrapR', 'wrapR', 'NUM', '', '0-CLAMP_ADDRESSMODE\n1-WRAP_ADDRESSMODE\n2-MIRROR_ADDRESSMODE'],
  wrapU = ['wrapU', 'wrapU', 'NUM', '', '0-CLAMP_ADDRESSMODE\n1-WRAP_ADDRESSMODE\n2-MIRROR_ADDRESSMODE'],
  wrapV = ['wrapV', 'wrapV', 'NUM', '', '0-CLAMP_ADDRESSMODE\n1-WRAP_ADDRESSMODE\n2-MIRROR_ADDRESSMODE'];

MenuGenerator.Texture = new DropdownHelper([
  anisotropicFilteringLevel,
  coordinatesMode,
  hasAlpha,
  invertY,
  invertZ,
  level,
  uAng,
  uOffset,
  uRotationCenter,
  uScale,
  url,
  vAng,
  vOffset,
  vRotationCenter,
  vScale,
  wAng,
  wRotationCenter,
  wrapR,
  wrapU,
  wrapV,
])

MenuGenerator.CubeTexture = new DropdownHelper([
  anisotropicFilteringLevel,
  coordinatesMode,
  hasAlpha,
  invertZ,
  level,
  url,
  rotationY,
  wrapU,
  wrapV,
])

export default MenuGenerator